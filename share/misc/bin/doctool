#!/bin/sh
# doctool - (re)create development documentation for source code/ libraries/
#           classes

scriptversion=2008-10-03.22
scriptname=doctool
maintainermail=bienert@zbh.uni-hamburg.de


# Copyright (C) 2008 Stefan Bienert
#
# This file is part of CoRB.
#
# CoRB is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# CoRB is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CoRB.  If not, see <http://www.gnu.org/licenses/>.


# variables - begin
TRAP_FILES="";         # put files which should be removed on script exit
CO_MODE="combineonly"; # mode flags
SO_MODE="striponly";

# supported programming languages:
#   all file extensions of supported languages are listed in SUP_LANGS
#   comments? form c_cmt="/*" assemble using expr?
SUP_LANGS="c C h H pl";
TR_LANG="c c h c cpp c cxx c hxx c"

# support for C
c_opn_comment="\/\*"
c_cls_comment="\*\/"
c_sty_comment="\*"

# help text
usage="Usage: $scriptname [OPTIONS] <source file>

$scriptname is used to create source/ library/ class documentation for software
projects. Possible output formats are pdf, html and man pages. Documentation is
created from two sources: First, the pure api documentation is stripped from
special tags in the source code and written to a file with extension m4. For
other output formats than man pages, further descriptions can be incorporated
from independent files. This is intended to help you setting up documentation
for entities which consist of more than one code file (e.g. libraries) or no
source code at all (e.g. project description).

Options:
--strip-only,   -s  Only strip the documentation texts from the source code.
--combine-only, -c  Only perform the combining step without stripping.
--help,         -h  display this help and exit.
--version           display version info and exit.

Report bugs to $maintainermail.
";
#variables - end

# functions - begin
# write a message in style scriptname: msg
report_err()
{
    echo "$scriptname: $1" >&2;
}

# write an error message with a usage hint
report_usage_err()
{
    report_err "$1";
    printf "%*c%s\n" `expr ${#scriptname} + 2` " " \
           "Try \`$scriptname --help' for more information." >&2;
}

report_bug()
{
    echo "Bug in $scriptname at line $LINENO: $1" >&2;
}

# create temporary files
spwntemp()
{
    created=0;
    tries=0;
    tmpname=`date "+%S%u%j%V%b%M"`;
    no=50;

    # try 50 times to create a file which was not there before
    while test $tries -lt $no;
    do
        tries=`expr $tries + 1`;
        if test -f $tmpname; then           # check if file name is occupied
            tmpname=`date "+%S%u%j%V%b%M"`;
        else
            touch "$tmpname" || return 1;
            echo $tmpname;
            return 0;
        fi
    done

    report_err "No unique file name found after $no tries.";

    return 1;
}

# exit script
exit_failure()
{
    echo "...aborting." >&2;
    exit 1;
}

# check for supported programming language file extension
check_extension_supported()
{
    if test $# -eq 1; then :;
    else
        report_bug "check_extension_supported(): No file extension specified.";
        return 1;
    fi

    for i in $SUP_LANGS; do
        if test $1 = $i; then
            return 0;
        fi
    done;

    return 1;
}

# translate file extensions to one defined for a language
tr_lang_ext()
{
    if test $# -eq 1; then :;
    else
        report_bug "tr_lang_ext(): No file extension specified.";
        return 1;
    fi

    cur=0;

    for i in $TR_LANG; do
        if test $cur -eq 0; then
            ext=$i
            cur=1;
        else
            if test $1 = $ext; then
                echo $i;
                return
            fi
            cur=0;
        fi
    done
}

# match expression in a line with a defined starting point
match_from_line_pos()
{
    # arg 1: expr
    # arg 2: start pos
    # arg 3: line

    if test $# -eq 3; then :;
    else
        report_bug "match_from_line_pos(): Missing argument.";
        return 1;
    fi

    #echo "Expr: " $1;
    #echo "Start: " $2;
    echo "Line: $3";
    #echo "blablub" | awk '{ print substr ($1, 1) }'
    #echo "$3" | awk '{ print match (substr ($1, 1), "/*") }'
    echo "$3" | awk ' { print $1 }'
    return 0;
}

# functions - end

# main - begin
mode="all"; # set working mode of script, initial: do stribbing & combining
in_file=""; # input source file

# init trap to clean up files created during bootstrapping
trap ' rm -f ${TRAP_FILES}' INT QUIT ABRT KILL TERM EXIT;

# parse commandline
s_is_set=0;
c_is_set=0;
exp_param=0;
split=0;

if test $# -lt 1; then
    report_usage_err "Missing argument.";
    exit_failure;
fi

while test $# -ne 0; do
    if test $exp_param -ne 0; then
        split=0;
        exp_param=0;
    fi

    # split option and parameter at "="
    if test $1="-*=*"; then
        pos=$1;
        shift;
        set -- `echo $pos | awk '{ l=index($1, "="); a=substr($1,0,l-1); \
                printf("%s",a); b=substr($1,l+1); printf(" %s", b);}'` $@;
    fi

    # preprocessing
    case $1 in
        -[!-?]?*)  # split first option of condensed opt.string
            pos=$1;
            shift;
            set -- `echo $pos | awk '{ a=substr($1,0,2); b=substr($1,3); \
                                printf("%s %s", a, b); }'` $@;
            split=1;
            ;;
        [!-]*) # rebuild formerly split opt.string
            if test $split -ne 0; then
                pos=$1;
                shift;
                set -- `echo $pos | awk '{ a=substr($1,0,1); b=substr($1,2); \
                                    printf("-%s %s"), a, b}'` $@;
                split=0;
            fi
            ;;
    esac

    # processing options
    case $1 in
        --strip-only|-s)
            mode=$SO_MODE;
            s_is_set=1;
            shift;
            continue;
            ;;

        --combine-only|-c)
            mode=$CO_MODE;
            c_is_set=1;
            shift;
            continue;
            ;;

        --version)
            echo "$0 $scriptversion"; exit $?;
            ;;
        
        --help|-h)
            echo "$usage"; exit $?;
            ;;
    esac

    # fetch a parameter to an option
    if test $exp_param -ne 0; then
        if test -z $param_store; then
            report_bug "\"\$param_store\" not set.";
            exit_failure;
        fi
        if test ! $1; then
            report_usage_err "Option \"${curr_option}\" needs a parameter.";
            exit_failure;
        fi    
        eval $param_store=$1;
        param_store="";
        shift;
        continue;
    fi

    # fetch script argument (arg not belonging to an option)
    if test $# -eq 1; then
      in_file=$1;
      shift;
      continue;
    fi

    # fetching unknown options and superfluous parameters
    case $1 in
        -*)
            report_usage_err "Invalid option: $1";
	    exit_failure;
            ;;
        *)
            report_usage_err "Superfluous argument: $1";
	    exit_failure;
            ;;
    esac
done

if test $s_is_set -eq 1 && test $c_is_set -eq 1; then
    report_usage_err "Options \"--strip-only, -s\" and \"--combine-only, -c\" exclude each other.";
    exit_failure;
fi

# check for source file
if test $c_is_set -eq 1; then # combine-only mode, no source file allowed
    if test ${#in_file} -eq 0; then :;
    else
        report_usage_err "Option \"--combine-only, -c\" does not allow input file argument.";
        exit_failure;
    fi
else # file mandatory
    if test ${#in_file} -eq 0; then
        report_usage_err "Missing input file argument.";
        exit_failure;        
    else # check file exists
        if test -f $in_file; then # file found, determine programming language
            lang_ext=${in_file##*.};     # get file extension
            check_extension_supported $lang_ext;
            if test $? -ne 0; then
                report_err "Language of \"$in_file\" not supported.";
                exit_failure;
            fi
            # transform extension to common one, e.g. for '*.h' set 'c'
            # 1) transform to lowercase
            lang_ext=`echo $lang_ext | tr [[:upper:]] [[:lower:]]`;
            # 2) transform arbitrary letter to identitfier
            lang_ext=`tr_lang_ext $lang_ext`;
        else # file no found
            report_err "File not found: \"$in_file\"";
            exit_failure;
        fi
    fi   
fi

srcname=`echo ${in_file%.$lang_ext}` # get name without extension
trgtname=${srcname}.m4               # create target filename

# strip documentation from source code and write to m4 files
if test $mode = $CO_MODE; then :; else # outer if

  # check if m4 file already exists,
  proc="no";
  if test -f $trgtname; then
    # then check age against source file
    `find ./$trgtname -name $trgtname -newer $in_file | grep -q "^./$trgtname"`
    if test $? -eq 1; then
        proc="yes";
    fi
  else
      proc="yes";
  fi

  if test $proc = "yes"; then
      echo "Strip it, baby!"
      # set comment symbols
      eval opn_comment='$'${lang_ext}_opn_comment
      eval cls_comment='$'${lang_ext}_cls_comment
      eval sty_comment='$'${lang_ext}_sty_comment

      # sed s/^[[:space:]]*[*][[:space:]]*//
      state="close_comment";
      while read line; do
          #echo "|$line|"
     # HIER:
          match_from_line_pos "${opn_comment}" 0 "$line"
          # only fetch comment lines, check open comment/ close comment
          echo "${line}" | grep -q "${opn_comment}";
          if test $? -eq 0; then
              state="open_comment"
          fi

          case $state in 
              "open_comment") echo "";;
              "close_comment") echo "";;
          esac
          # 1) fetch new state depending on current
          # 2) process (fetch something else)
          # 3) fetch end of line (fetch for closing comment?)
          # fetch environments
          # strip commentaries from lines
          # write lines to file
      done < $in_file;
      #echo ${in_file%.c}
      # search for opening environment tags
      #   translate to doc-lang
      #   push closing tag on stack
      #   write to m4 file until closing tag
  fi
fi # outer if

# combine everything to documentation
if test $mode =  $SO_MODE; then :; else
  echo "Combine it, baby!"
fi

exit 0;
# main - end

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-end: "$"
# End:
